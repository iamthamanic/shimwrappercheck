{
  "common": {
    "appName": "shimwrappercheck",
    "dashboard": "Dashboard",
    "settings": "Settings",
    "config": "Config",
    "agentsMd": "AGENTS.md",
    "myshim": "myshim",
    "search": "Search...",
    "searchFulltext": "Full-text search …",
    "all": "All",
    "frontend": "Frontend",
    "backend": "Backend",
    "enforce": "Enforce",
    "hooks": "Hooks",
    "info": "Info",
    "settingsLabel": "Settings",
    "logs": "Logs",
    "noLogYet": "No log for this check yet. Run checks to see output.",
    "active": "Active",
    "inactive": "Inactive",
    "copy": "Copy",
    "copied": "Copied!",
    "close": "Close",
    "closeLower": "close",
    "remove": "Remove",
    "save": "Save",
    "saving": "Saving…",
    "saveFailed": "Save failed.",
    "cancel": "Cancel",
    "name": "Name",
    "export": "Export",
    "rename": "Rename",
    "loading": "Loading…",
    "preset": "Preset",
    "templates": "Templates",
    "information": "Information",
    "presetsAndSettings": "Templates & Settings",
    "runOrder": "Run order",
    "showLarger": "Show larger",
    "details": "Details",
    "expandDetails": "Show details",
    "collapseDetails": "Hide details",
    "toolPresent": "present",
    "toolNotFound": "not found",
    "toolLabel": "Tool",
    "statusPresent": "✓ Present",
    "statusMissing": "— Not found",
    "noResults": "No results.",
    "dragToActivate": "Drag to My Shim to activate",
    "addToMyShim": "Add to My Shim",
    "matches": "matches",
    "updated": "updated",
    "unknownCommands": "Unknown or invalid commands",
    "clickToEdit": "Click to edit",
    "enforceHint": "Allowed: git push, supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksHint": "Supabase only: supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksOnlySupabase": "Only Supabase commands allowed.",
    "searchTriggerCommandos": "Full-text search in Trigger Commandos",
    "commandEnterPlaceholder": "Enter command, Enter for new tag",
    "commandExampleEnforce": "e.g. git push, Enter for new tag",
    "commandExampleHooks": "e.g. supabase functions deploy (Supabase only), Enter for new tag",
    "commandNewTag": "Enter command, Enter for new tag",
    "dropHereActivate": "Drop here – activate check",
    "dropHereDeactivate": "Drop here – deactivate check",
    "insertHere": "Insert here",
    "noMyChecksYet": "No My Checks yet. Drag from Check Library here.",
    "dragFromLibrary": "Drag checks from Check Library into the area above to activate them.",
    "removeFromMyShim": "Remove from My Shim (back to Check Library)",
    "dragToReorder": "Drag to reorder",
    "dashboardTitle": "shimwrappercheck Dashboard",
    "dashboardDescription": "Config & AGENTS.md for shimwrappercheck"
  },
  "nav": {
    "dashboard": "Dashboard",
    "settings": "Settings",
    "config": "Config",
    "agentsMd": "AGENTS.md"
  },
  "header": {
    "settingsAria": "Settings"
  },
  "sidebar": {
    "myActiveShim": "My Active Shim"
  },
  "triggerCommandos": {
    "title": "My Trigger Commandos"
  },
  "checkLibrary": {
    "title": "Check Library"
  },
  "myChecks": {
    "title": "My Checks"
  },
  "settings": {
    "loadError": "Settings could not be loaded.",
    "timeout": "Timeout. Please try again.",
    "loadFailed": "Loading failed.",
    "retry": "Retry",
    "saved": "Settings saved.",
    "saveFailed": "Save failed.",
    "savedShort": "Saved.",
    "presetRenamed": "Preset renamed.",
    "uiPortTitle": "UI – Port",
    "uiPortDesc": "Which port the UI should use or whether a free port is chosen automatically.",
    "portAuto": "Automatically choose a free port",
    "portFixed": "Fixed port:",
    "savePort": "Save port setting",
    "version": "Version:",
    "lastUpdated": "Last updated:",
    "statusTitle": "Status",
    "projectRoot": "Project root:",
    "lastCheckError": "Last check error (.shim/last_error.json)",
    "suggestion": "Suggestion:",
    "actionsTitle": "Actions",
    "runChecks": "Run checks only",
    "running": "Running…",
    "configRaw": "Config (Raw)",
    "editAgentsMd": "Edit AGENTS.md",
    "lastCheckOutput": "Last check output",
    "ok": "(OK)",
    "error": "(Error)",
    "noOutput": "(no output)",
    "presetIntro": "Choose preset and enable/disable checks. Trigger commands (Supabase/Git) are set in My Shim. Save writes .shimwrappercheckrc.",
    "presetStorageHint": "Presets are saved in this project. Use Export to reuse in another project.",
    "presetTitle": "Preset",
    "presetOptions": "Options for active preset",
    "presetOptionsAria": "Preset options",
    "deletePreset": "Delete preset",
    "newPreset": "New preset",
    "createPreset": "Create",
    "exportPreset": "Export preset",
    "exportFilenameHint": "Filename (will be downloaded as .json):",
    "exportPlaceholder": "my-preset.json",
    "renamePreset": "Rename preset",
    "renamePresetHint": "New name (also shown in My Shim):",
    "providersTitle": "Providers in this preset",
    "providersDesc": "Add providers (e.g. GitHub, Supabase).",
    "github": "GitHub",
    "supabase": "Supabase",
    "removeProvider": "remove",
    "runChecksRequestFailed": "Request failed."
  },
  "statusCard": {
    "configRc": ".shimwrappercheckrc",
    "presetsFile": "Presets (.shimwrappercheck-presets.json)",
    "presetsDetail": "Presets & check toggles (settings)",
    "agentsMd": "AGENTS.md",
    "agentsMdDetail": "Agent instructions (editable via GUI)",
    "runChecksScript": "scripts/run-checks.sh",
    "shimRunner": "Shim Runner",
    "shimRunnerDetail": "Node orchestrator (npx shimwrappercheck run)",
    "huskyPrePush": "Husky pre-push",
    "gitPrePushHook": "Git pre-push Hook",
    "supabase": "Supabase"
  },
  "config": {
    "title": "Config (.shimwrappercheckrc)",
    "description": "Shell variables and comments. Used on next shim invocation.",
    "placeholder": "# shimwrappercheck config\nSHIM_ENFORCE_COMMANDS=\"functions,db,migration\"\n...",
    "saved": "Config saved."
  },
  "agents": {
    "title": "AGENTS.md",
    "description": "Agent instructions for Cursor/Codex. Read by agents; editable here. Changes apply immediately.",
    "notExists": "AGENTS.md does not exist yet. It will be created in the project root when you save.",
    "placeholder": "# Agent instructions...",
    "saved": "AGENTS.md saved."
  },
  "notFound": {
    "title": "Page not found",
    "description": "The requested URL does not exist."
  },
  "error": {
    "title": "Error",
    "fallbackMessage": "An unexpected error occurred.",
    "retry": "Retry"
  },
  "checks": {
    "lint": {
      "label": "ESLint",
      "summary": "Checks code for style issues and common error sources.",
      "info": "Context: Unused variables, typos, or project rule violations often cause hard-to-find bugs and inconsistent code. Solution: npm run lint (ESLint) is run. Pass: ESLint exits with no reports (exit code 0). Fail: ESLint reports errors or, depending on config, warnings."
    },
    "prettier": {
      "label": "Prettier",
      "summary": "Ensures consistent code formatting.",
      "info": "Context: Inconsistent indentation, quotes, or line breaks make changes harder to read and distract from content in code reviews. Solution: Prettier runs in check mode (e.g. npm run format:check or prettier --check). Pass: All checked files match the configured format. Fail: At least one file does not."
    },
    "typecheck": {
      "label": "TypeScript Check",
      "summary": "Checks that TypeScript types are consistent.",
      "info": "Context: TypeScript catches many errors before run time (wrong types, missing properties). Without this check, faulty code can be shipped. Solution: The TypeScript compiler runs without building (tsc --noEmit or npm run typecheck). Pass: No type errors. Fail: The compiler reports one or more type errors."
    },
    "testRun": {
      "label": "Vitest",
      "summary": "Runs automated tests; continues only if all pass.",
      "info": "Context: Without tests, changes can break existing behaviour unnoticed; users then see failures. Solution: The test suite is run (e.g. npm run test or Vitest). Pass: All tests pass. Fail: At least one test fails – push/deploy is blocked."
    },
    "projectRules": {
      "label": "Project rules",
      "summary": "Checks project-specific rules (structure, naming, imports).",
      "info": "Context: Projects can have their own rules (e.g. allowed folders, file naming, what may be imported). Breaking them causes clutter and technical debt. Solution: The script scripts/checks/project-rules.sh is run. Pass: The script exits with code 0. Fail: The script reports violations. Note: The script must exist in the project."
    },
    "npmAudit": {
      "label": "npm audit",
      "summary": "Scans npm dependencies for known security vulnerabilities.",
      "info": "Context: Libraries can have known vulnerabilities; shipping them can put users or data at risk. Solution: npm audit is run. The level (critical, high, moderate, low) sets the severity threshold for failure. Pass: No vulnerabilities at or above that level. Fail: At least one vulnerability at or above that level.",
      "auditLevel": "Audit level",
      "auditLevelTooltip": "Severity threshold for failure: critical (only critical), high (critical + high), moderate (+ moderate), low (+ low). Higher level = stricter."
    },
    "viteBuild": {
      "label": "Vite",
      "summary": "Checks that the frontend project builds without errors.",
      "info": "Context: If the build fails, deployment fails or a broken version is shipped. Solution: The build is run (e.g. npm run build with Vite). Pass: Build completes with no errors. Fail: Build fails with an error – push/deploy is blocked."
    },
    "snyk": {
      "label": "Snyk",
      "summary": "Extra scan for security issues in dependencies (when Snyk is installed).",
      "info": "Context: npm audit does not cover all sources; Snyk can find additional vulnerabilities. Solution: Snyk is run if installed in the project. Pass: Snyk reports no issues, or Snyk is not installed (then the check is skipped). Fail: Snyk reports issues. Without Snyk installed, the check does not run."
    },
    "denoFmt": {
      "label": "Deno fmt",
      "summary": "Checks formatting of backend/Edge Function code (Deno).",
      "info": "Context: Code in supabase/functions (Deno) should be consistently formatted so changes stay readable. Solution: deno fmt --check is run for supabase/functions. Pass: Code matches Deno default formatting. Fail: At least one file does not."
    },
    "denoLint": {
      "label": "Deno lint",
      "summary": "Checks Deno code (backend/functions) for errors and bad practice.",
      "info": "Context: Backend and Edge Function code can have bugs or problematic patterns; lint finds them before deploy. Solution: deno lint is run for supabase/functions. Pass: No lint messages. Fail: The linter reports one or more violations."
    },
    "denoAudit": {
      "label": "Deno audit",
      "summary": "Scans Deno dependencies (backend/functions) for known vulnerabilities.",
      "info": "Context: Deno dependencies can have known vulnerabilities; they should be checked before deploy. Solution: deno audit is run in the relevant directory (e.g. supabase/functions/server). Pass: No reported vulnerabilities. Fail: One or more vulnerabilities reported."
    },
    "aiReview": {
      "label": "AI Review",
      "summary": "Has an AI (Codex) review the code against a checklist.",
      "info": "Context: Code can look fine but have weaknesses in architecture, security, or maintainability; an automated review gives a second opinion. Solution: The selected code (changes only or full codebase per directory) is sent to Codex; Codex scores it against a fixed checklist (e.g. SOLID, performance, security) and returns a score and verdict (ACCEPT/REJECT). Pass: Verdict ACCEPT and score at or above the configured minimum (default 95). Fail: REJECT or score below that. Requirement: Codex CLI installed and logged in. Reports are saved in .shimwrapper/reviews/.",
      "timeoutSec": "Timeout (seconds)",
      "timeoutSecTooltip": "Maximum runtime for the AI review in seconds. On timeout the check fails. Consider increasing for large diffs or full codebase mode.",
      "checkMode": "AI review scope",
      "checkModeTooltip": "diff: Only changed code is reviewed (staged, unstaged, or commits being pushed). Faster, focused on your changes. full (chunked): Codebase is reviewed per directory (src, supabase, scripts)—one diff per dir up to 150 KB, one Codex run per chunk (timeout 600 s). PASS only if all chunks get ACCEPT and score ≥ 95. The saved review file shows „Mode: diff“ or „Mode: full (chunked)“.",
      "checkModeOptionDiff": "diff — only changes (staged/unstaged or pushed commits)",
      "checkModeOptionFull": "full — whole codebase (truncated to ~100KB)",
      "diffLimitBytes": "Max diff size (bytes)",
      "diffLimitBytesTooltip": "Maximum size of the diff sent to the AI in bytes. Larger diffs are truncated. Relevant in full mode. Default 51200 (~50 KB).",
      "minRating": "Minimum rating for PASS",
      "minRatingTooltip": "Score (0–100) required for the AI review to pass. Below this value the check fails. Default 95.",
      "reviewDir": "Review output folder",
      "reviewDirTooltip": "Directory where review reports (e.g. .md files) are saved. Path relative to project root."
    },
    "explanationCheck": {
      "label": "Full Explanation",
      "summary": "Checks that every part of the code is explained (docstrings and comments).",
      "info": "Context: Unexplained code is hard to maintain; this project requires every function and non-trivial logic to be justified. Solution: The changed code is sent to Codex; Codex checks for docstrings and meaningful inline comments. Pass: Score at least 95 and verdict ACCEPT. Fail: Below that or REJECT. Reports in .shimwrapper/reviews/explanation-check-*.md. Requirement: Codex CLI available."
    },
    "i18nCheck": {
      "label": "i18n / Translations",
      "summary": "Checks that all text keys used in code exist in every language file.",
      "info": "Context: In multilingual apps, every displayed text must be defined for each language; missing entries show raw keys or wrong text to users. Solution: Source code is scanned for translation calls and compared with files in messages/*.json. Pass: Every key used in code exists in every locale file. Fail: At least one key is missing in at least one language. Optional: --fix can add missing keys as placeholders (scripts/i18n-check.js)."
    },
    "checkMockData": {
      "label": "Check Mock Data",
      "summary": "Checks that the project’s mock/test data is valid and consistent.",
      "info": "Context: Invalid or inconsistent mock data can skew tests or hide bugs. Solution: The project’s check:mock-data script is run (if defined in package.json). Pass: Script exits with code 0. Fail: Script reports errors or exits with a non-zero code. Without a defined script, the check is skipped."
    },
    "updateReadme": {
      "label": "Update README",
      "summary": "Runs a script that e.g. updates the version in the README.",
      "info": "Context: README and docs go stale; a script can at least update parts (e.g. version from package.json). Solution: The update-README script (from package or project) is run. Pass: Script runs without error. Fail: Script fails. Note: What is updated depends on the script; content changes still need to be done manually."
    },
    "sast": {
      "label": "Semgrep",
      "summary": "Static analysis with Semgrep: finds security patterns and rule violations in code.",
      "info": "Context: Semgrep is a static analysis (SAST) tool with rule-based checks. Solution: semgrep scan is run (e.g. with --config auto). Pass: No findings. Fail: Semgrep reports matches. Tool must be installed (pip install semgrep or npx semgrep)."
    },
    "gitleaks": {
      "label": "Gitleaks",
      "summary": "Scans the repo for accidentally committed secrets (API keys, passwords).",
      "info": "Context: Gitleaks detects known secret patterns in the codebase and git history. Solution: gitleaks detect is run. Pass: No matches. Fail: At least one secret found. Tool must be installed (e.g. Homebrew or gitleaks.io)."
    },
    "licenseChecker": {
      "label": "license-checker",
      "summary": "Checks npm dependency licenses; fails if disallowed licenses are found.",
      "info": "Context: The license-checker tool lists licenses of all dependencies. Solution: npx license-checker is run with configurable allowed/disallowed licenses. Pass: No disallowed licenses. Fail: At least one disallowed license. Configurable via .licensecheckerrc or CLI options."
    },
    "architecture": {
      "label": "Architecture",
      "summary": "Checks that architecture rules are followed (currently only available as an option).",
      "info": "Context: Architecture rules (e.g. no forbidden dependencies, layer order) keep the codebase structured. Solution: This check exists in config but is not run by the default run-checks.sh. Enabling it only stores the preference; the check must be implemented in the project (e.g. with dependency-cruiser)."
    },
    "complexity": {
      "label": "Complexity",
      "summary": "Warns about overly complex code (currently only available as an option).",
      "info": "Context: Very nested or long code is error-prone and hard to maintain. Solution: This check exists in config but is not run by the default run-checks.sh. Enabling it only stores the preference; the check must be implemented in the project (e.g. with eslint-plugin-complexity)."
    },
    "mutation": {
      "label": "Mutation",
      "summary": "Checks whether tests actually catch bugs (currently only available as an option).",
      "info": "Context: Mutation tests change code slightly; if tests still pass, they may not cover the changed part. Solution: This check exists in config but is not run by the default run-checks.sh. Enabling it only stores the preference; the check must be implemented in the project (e.g. with Stryker)."
    },
    "e2e": {
      "label": "E2E",
      "summary": "End-to-end tests over the whole app (currently only available as an option).",
      "info": "Context: E2E tests simulate real users and test the app from start to finish. Solution: This check exists in config but is not run by the default run-checks.sh. Enabling it only stores the preference; tests must be set up in the project (e.g. with Playwright)."
    },
    "healthPing": {
      "label": "Post-Deploy: Health Ping",
      "summary": "After deploy: checks that the deployed Supabase Functions are reachable and respond.",
      "info": "Context: After a deploy, the app might still be unreachable or misconfigured; a quick request confirms the function responds. Solution: After a Supabase deploy, the configured health URLs of the Edge Functions are called over HTTP (script ping-edge-health.sh). Pass: The called endpoints respond (e.g. HTTP 200). Fail: No response or error. Requirement: Correct Project Ref and, if needed, health paths.",
      "defaultFunction": "Default function",
      "defaultFunctionTooltip": "Name of the Edge Function called by default via GET. Must expose a health endpoint.",
      "healthFunctions": "Additional functions (comma-separated)",
      "healthFunctionsTooltip": "Other function names to ping after deploy. Comma-separated.",
      "healthPaths": "Health paths (comma-separated, {fn})",
      "healthPathsTooltip": "Path per function; {fn} is replaced by the function name. Empty = default path.",
      "projectRef": "Supabase Project Ref",
      "projectRefTooltip": "Supabase Project Reference (e.g. from dashboard). Required for health URL."
    },
    "edgeLogs": {
      "label": "Post-Deploy: Edge Logs",
      "summary": "Fetches the latest Edge Function logs after deploy for inspection.",
      "info": "Context: After a deploy, logs show whether functions started correctly or threw errors. Solution: After deploy, the latest log lines of the configured Edge Function(s) are fetched (script fetch-edge-logs.sh). There is no explicit pass/fail – logs are only provided; you decide whether everything looks correct.",
      "defaultFunction": "Default function",
      "defaultFunctionTooltip": "Function whose logs are fetched by default.",
      "logFunctions": "Functions for logs (comma-separated)",
      "logFunctionsTooltip": "Which functions to fetch logs for. Comma-separated; empty = default only.",
      "logLimit": "Number of log lines",
      "logLimitTooltip": "Maximum log lines per fetch. Higher = more context, longer output."
    }
  }
}
