{
  "common": {
    "appName": "shimwrappercheck",
    "dashboard": "Dashboard",
    "settings": "Einstellungen",
    "config": "Config",
    "agentsMd": "AGENTS.md",
    "myshim": "myshim",
    "search": "Suchen...",
    "searchFulltext": "Volltextsuche …",
    "all": "Alle",
    "frontend": "Frontend",
    "backend": "Backend",
    "enforce": "Erzwingen",
    "hooks": "Hooks",
    "info": "Info",
    "settingsLabel": "Einstellungen",
    "logs": "Logs",
    "noLogYet": "Noch kein Log für diesen Check. Checks ausführen, um Ausgabe zu sehen.",
    "settingsNoExtra": "Keine weiteren Einstellungen. Der Check wird nur über „Aktiv“ (in My Checks) ein- oder ausgeschaltet.",
    "projectRulesTab": "Regeln",
    "projectRulesForm": "Formular",
    "projectRulesScript": "Skript",
    "projectRulesScriptPlaceholder": "Skript bearbeiten (wird als scripts/checks/project-rules.sh gespeichert). Exit 0 = bestanden.",
    "projectRulesFormPlaceholder": "Regeln per Formular (z. B. verbotene Imports) kommen in einer späteren Version. Nutze die Skript-Ansicht.",
    "projectRulesSaved": "Skript gespeichert.",
    "projectRulesAddRule": "Regel hinzufügen",
    "projectRulesRuleTypeForbiddenPattern": "Verbotenes Muster",
    "projectRulesRuleTypeMaxLines": "Max. Zeilen pro Datei",
    "projectRulesPatternLabel": "Muster (z. B. ../ oder from '@/../')",
    "projectRulesPatternPlaceholder": "z. B. ../",
    "projectRulesMaxLinesLabel": "Max. Zeilen",
    "projectRulesMaxLinesPlaceholder": "300",
    "projectRulesRuleTypeLabel": "Regeltyp",
    "projectRulesFormEmptyHint": "Noch keine Regeln. Klicke auf „Regel hinzufügen“, dann Speichern.",
    "active": "Aktiv",
    "inactive": "Inaktiv",
    "copy": "Kopieren",
    "copied": "Kopiert!",
    "close": "Schließen",
    "closeLower": "schließen",
    "remove": "Entfernen",
    "save": "Speichern",
    "saving": "Speichern…",
    "saveFailed": "Speichern fehlgeschlagen.",
    "cancel": "Abbrechen",
    "name": "Name",
    "export": "Export",
    "rename": "Umbenennen",
    "loading": "Laden…",
    "preset": "Preset",
    "templates": "Templates",
    "information": "Information",
    "presetsAndSettings": "Templates & Einstellungen",
    "runOrder": "Laufreihenfolge",
    "showLarger": "Größer anzeigen",
    "details": "Details",
    "expandDetails": "Details einblenden",
    "collapseDetails": "Details ausblenden",
    "toolPresent": "vorhanden",
    "toolNotFound": "nicht gefunden",
    "toolLabel": "Tool",
    "statusPresent": "✓ Vorhanden",
    "statusMissing": "— Nicht gefunden",
    "noResults": "Keine Treffer.",
    "dragToActivate": "Ziehen in My Shim zum Aktivieren",
    "addToMyShim": "Zu My Shim hinzufügen",
    "matches": "Treffer",
    "updated": "aktualisiert",
    "unknownCommands": "Unbekannte oder ungültige Befehle",
    "clickToEdit": "Klicken zum Bearbeiten",
    "enforceHint": "Erlaubt: git push, supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksHint": "Nur Supabase: supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksOnlySupabase": "Nur Supabase-Befehle erlaubt.",
    "searchTriggerCommandos": "Volltextsuche in Trigger Commandos",
    "commandEnterPlaceholder": "Befehl eingeben, Enter für neues Tag",
    "commandExampleEnforce": "z.B. git push, Enter für neues Tag",
    "commandExampleHooks": "z.B. supabase functions deploy (nur Supabase), Enter für neues Tag",
    "commandNewTag": "Befehl eingeben, Enter für neues Tag",
    "dropHereActivate": "Hier ablegen – Check aktivieren",
    "dropHereDeactivate": "Hier ablegen – Check deaktivieren",
    "insertHere": "Hier einfügen",
    "noMyChecksYet": "Noch keine My Checks. Aus der Check Library hierher ziehen.",
    "dragFromLibrary": "Checks aus der Check Library in die Fläche oben ziehen, um sie zu aktivieren.",
    "removeFromMyShim": "Aus My Shim entfernen (zurück in Check Library)",
    "dragToReorder": "Ziehen zum Sortieren",
    "dashboardTitle": "shimwrappercheck Dashboard",
    "dashboardDescription": "Config & AGENTS.md für shimwrappercheck"
  },
  "nav": {
    "dashboard": "Dashboard",
    "settings": "Einstellungen",
    "config": "Config",
    "agentsMd": "AGENTS.md"
  },
  "header": {
    "settingsAria": "Einstellungen"
  },
  "sidebar": {
    "myActiveShim": "Mein aktiver Shim"
  },
  "triggerCommandos": {
    "title": "Meine Trigger-Commandos"
  },
  "checkLibrary": {
    "title": "Check-Bibliothek",
    "scanCodebase": "Suggest Checks",
    "scanCodebaseScanning": "Scanne…",
    "scanError": "Scan fehlgeschlagen. Bitte erneut versuchen.",
    "clickToDismiss": "Klicken zum Schließen"
  },
  "myChecks": {
    "title": "Meine Checks"
  },
  "settings": {
    "loadError": "Einstellungen konnten nicht geladen werden.",
    "timeout": "Zeitüberschreitung. Bitte erneut versuchen.",
    "loadFailed": "Laden fehlgeschlagen.",
    "retry": "Erneut versuchen",
    "saved": "Einstellungen gespeichert.",
    "saveFailed": "Speichern fehlgeschlagen.",
    "savedShort": "Gespeichert.",
    "presetRenamed": "Preset umbenannt.",
    "uiPortTitle": "Grafische UI – Port",
    "uiPortDesc": "Auf welchem Port die UI starten soll oder ob automatisch ein freier Port gewählt wird.",
    "portAuto": "Automatisch einen freien Port wählen",
    "portFixed": "Fester Port:",
    "savePort": "Port-Einstellung speichern",
    "version": "Version:",
    "lastUpdated": "Zuletzt aktualisiert:",
    "statusTitle": "Status",
    "projectRoot": "Projekt-Root:",
    "lastCheckError": "Letzter Check-Fehler (.shim/last_error.json)",
    "suggestion": "Vorschlag:",
    "actionsTitle": "Aktionen",
    "runChecks": "Nur Checks ausführen",
    "running": "Läuft…",
    "configRaw": "Config (Raw)",
    "editAgentsMd": "AGENTS.md bearbeiten",
    "lastCheckOutput": "Letzte Check-Ausgabe",
    "ok": "(OK)",
    "error": "(Fehler)",
    "noOutput": "(keine Ausgabe)",
    "presetIntro": "Preset wählen und Checks ein-/ausschalten. Trigger-Befehle (Supabase/Git) legst du in My Shim fest. Speichern schreibt .shimwrappercheckrc.",
    "presetStorageHint": "Presets werden in diesem Projekt gespeichert. Export nutzen, um sie in einem anderen Projekt wiederzuverwenden.",
    "presetTitle": "Preset",
    "presetOptions": "Optionen für aktives Preset",
    "presetOptionsAria": "Preset-Optionen",
    "deletePreset": "Preset löschen",
    "newPreset": "Neues Preset",
    "createPreset": "Anlegen",
    "exportPreset": "Preset exportieren",
    "exportFilenameHint": "Dateiname (wird als .json heruntergeladen):",
    "exportPlaceholder": "mein-preset.json",
    "renamePreset": "Preset umbenennen",
    "renamePresetHint": "Neuer Name (wird auch in My Shim angezeigt):",
    "providersTitle": "Provider in diesem Preset",
    "providersDesc": "Provider hinzufügen (z. B. GitHub, Supabase).",
    "github": "GitHub",
    "supabase": "Supabase",
    "removeProvider": "entfernen",
    "runChecksRequestFailed": "Anfrage fehlgeschlagen."
  },
  "statusCard": {
    "configRc": ".shimwrappercheckrc",
    "presetsFile": "Presets (.shimwrappercheck-presets.json)",
    "presetsDetail": "Presets & Check-Toggles (Einstellungen)",
    "agentsMd": "AGENTS.md",
    "agentsMdDetail": "Agent-Anweisungen (über GUI bearbeitbar)",
    "runChecksScript": "scripts/run-checks.sh",
    "shimRunner": "Shim Runner",
    "shimRunnerDetail": "Node-Orchestrator (npx shimwrappercheck run)",
    "huskyPrePush": "Husky pre-push",
    "gitPrePushHook": "Git pre-push Hook",
    "supabase": "Supabase"
  },
  "config": {
    "title": "Config (.shimwrappercheckrc)",
    "description": "Shell-Variablen und Kommentare. Wird beim nächsten Aufruf des Shims verwendet.",
    "placeholder": "# shimwrappercheck config\nSHIM_ENFORCE_COMMANDS=\"functions,db,migration\"\n...",
    "saved": "Config gespeichert."
  },
  "agents": {
    "title": "AGENTS.md",
    "description": "Agent-Anweisungen für Cursor/Codex. Wird von Agents gelesen; hier bearbeitbar. Änderungen gelten sofort.",
    "notExists": "AGENTS.md existiert noch nicht. Beim Speichern wird sie im Projekt-Root angelegt.",
    "placeholder": "# Agent instructions...",
    "saved": "AGENTS.md gespeichert."
  },
  "notFound": {
    "title": "Seite nicht gefunden",
    "description": "Die angeforderte URL existiert nicht."
  },
  "error": {
    "title": "Fehler",
    "fallbackMessage": "Ein unerwarteter Fehler ist aufgetreten.",
    "retry": "Erneut versuchen"
  },
  "checks": {
    "lint": {
      "label": "ESLint",
      "summary": "Prüft den Code auf Stilfehler und typische Fehlerquellen.",
      "info": "Kontext: Ungenutzte Variablen, Tippfehler oder Verstöße gegen Projektregeln führen oft zu schwer auffindbaren Fehlern und uneinheitlichem Code. Lösung: Es wird npm run lint (ESLint) ausgeführt. Bestanden: ESLint beendet ohne Meldungen (Exit-Code 0). Nicht bestanden: ESLint meldet Fehler oder – je nach Konfiguration – Warnungen."
    },
    "prettier": {
      "label": "Prettier",
      "summary": "Stellt einheitliche Code-Formatierung sicher.",
      "info": "Kontext: Unterschiedliche Einrückung, Anführungszeichen oder Zeilenumbrüche machen Änderungen schwer lesbar und lenken in Code-Reviews vom Inhalt ab. Lösung: Prettier wird im Prüfmodus ausgeführt (z. B. npm run format:check oder prettier --check). Bestanden: Alle geprüften Dateien entsprechen der konfigurierten Formatierung. Nicht bestanden: Mindestens eine Datei weicht ab."
    },
    "typecheck": {
      "label": "TypeScript Check",
      "summary": "Prüft, ob die Typen im TypeScript-Code zusammenpassen.",
      "info": "Kontext: TypeScript erkennt viele Fehler vor dem Ausführen (falsche Typen, fehlende Eigenschaften). Ohne diese Prüfung kann fehlerhafter Code ausgeliefert werden. Lösung: Der TypeScript-Compiler läuft ohne Build (tsc --noEmit bzw. npm run typecheck). Bestanden: Keine Typfehler. Nicht bestanden: Der Compiler meldet einen oder mehrere Typfehler."
    },
    "testRun": {
      "label": "Vitest",
      "summary": "Führt die automatisierten Tests aus; nur bei Erfolg geht es weiter.",
      "info": "Kontext: Ohne Tests können Änderungen bestehende Funktionen unbemerkt kaputt machen; Nutzer sehen dann Fehler. Lösung: Die Test-Suite wird ausgeführt (z. B. npm run test oder Vitest). Bestanden: Alle Tests laufen grün. Nicht bestanden: Mindestens ein Test schlägt fehl – Push/Deploy wird blockiert."
    },
    "projectRules": {
      "label": "Projektregeln",
      "summary": "Prüft projektspezifische Regeln (Struktur, Namenskonventionen, Imports).",
      "info": "Kontext: Jedes Projekt kann eigene Regeln haben (z. B. welche Ordner erlaubt sind, wie Dateien heißen, was importiert werden darf). Werden sie gebrochen, entsteht Unordnung und technische Schulden. Lösung: Das Skript scripts/checks/project-rules.sh wird ausgeführt. Bestanden: Das Skript endet mit Exit-Code 0. Nicht bestanden: Das Skript meldet Verstöße. Hinweis: Das Skript muss im Projekt vorhanden sein."
    },
    "npmAudit": {
      "label": "npm audit",
      "summary": "Sucht in den npm-Abhängigkeiten nach bekannten Sicherheitslücken.",
      "info": "Kontext: Bibliotheken können bekannte Sicherheitslücken haben; werden sie ausgeliefert, können Nutzer oder Daten gefährdet sein. Lösung: npm audit wird ausgeführt. Die Stufe (critical, high, moderate, low) legt fest, ab welcher Schwere der Check fehlschlägt. Bestanden: Keine gefundenen Lücken auf oder über dieser Stufe. Nicht bestanden: Mindestens eine Lücke auf oder über der Stufe.",
      "auditLevel": "Audit-Stufe",
      "auditLevelTooltip": "Ab welcher Schwere der Check fehlschlägt: critical (nur Kritisch), high (Kritisch + Hoch), moderate (+ Mittel), low (+ Niedrig). Höhere Stufen = strenger."
    },
    "viteBuild": {
      "label": "Vite",
      "summary": "Prüft, ob das Frontend-Projekt fehlerfrei gebaut werden kann.",
      "info": "Kontext: Wenn der Build fehlschlägt, schlägt auch das Deployment fehl oder es wird eine kaputte Version ausgeliefert. Lösung: Der Build wird ausgeführt (z. B. npm run build mit Vite). Bestanden: Der Build endet ohne Fehler. Nicht bestanden: Der Build bricht mit Fehlermeldung ab – Push/Deploy wird blockiert."
    },
    "snyk": {
      "label": "Snyk",
      "summary": "Zusätzliche Prüfung auf Sicherheitslücken in Abhängigkeiten (wenn Snyk installiert ist).",
      "info": "Kontext: npm audit deckt nicht alle Quellen ab; Snyk kann weitere Schwachstellen kennen. Lösung: Snyk wird ausgeführt, sofern es im Projekt installiert ist. Bestanden: Snyk meldet keine Probleme, oder Snyk ist nicht installiert (dann wird der Check übersprungen). Nicht bestanden: Snyk meldet gefundene Lücken. Ohne Snyk-Installation läuft der Check nicht."
    },
    "denoFmt": {
      "label": "Deno fmt",
      "summary": "Prüft die Formatierung des Backend-/Edge-Function-Codes (Deno).",
      "info": "Kontext: Der Code in supabase/functions (Deno) soll einheitlich formatiert sein, damit Änderungen lesbar bleiben. Lösung: deno fmt --check wird für supabase/functions ausgeführt. Bestanden: Der Code entspricht der Deno-Standardformatierung. Nicht bestanden: Mindestens eine Datei weicht ab."
    },
    "denoLint": {
      "label": "Deno lint",
      "summary": "Prüft den Deno-Code (Backend/Functions) auf Fehler und schlechte Praxis.",
      "info": "Kontext: Auch Backend- und Edge-Function-Code kann Fehler oder problematische Muster enthalten; Lint findet sie vor dem Deploy. Lösung: deno lint wird für supabase/functions ausgeführt. Bestanden: Keine Lint-Meldungen. Nicht bestanden: Der Linter meldet einen oder mehrere Verstöße."
    },
    "denoAudit": {
      "label": "Deno audit",
      "summary": "Sucht in den Deno-Abhängigkeiten (Backend/Functions) nach bekannten Sicherheitslücken.",
      "info": "Kontext: Deno-Abhängigkeiten können bekannte Sicherheitslücken haben; sie sollten vor dem Deploy geprüft werden. Lösung: deno audit wird im relevanten Verzeichnis (z. B. supabase/functions/server) ausgeführt. Bestanden: Keine gemeldeten Schwachstellen. Nicht bestanden: Es werden eine oder mehrere Lücken gemeldet."
    },
    "aiReview": {
      "label": "AI Review",
      "summary": "Lässt eine KI (Codex) den Code anhand einer Checkliste prüfen.",
      "info": "Kontext: Code kann oberflächlich in Ordnung wirken, aber Schwächen in Architektur, Sicherheit oder Wartbarkeit haben; eine automatisierte Prüfung gibt eine zweite Meinung. Lösung: Der ausgewählte Code (nur Änderungen oder pro Verzeichnis die ganze Codebase) wird an Codex geschickt; Codex bewertet nach einer festen Checkliste (z. B. SOLID, Performance, Sicherheit) und vergibt Punkte sowie ein Urteil (ACCEPT/REJECT). Bestanden: Urteil ACCEPT und Bewertung mindestens so hoch wie eingestellt (Standard 95). Nicht bestanden: REJECT oder Bewertung darunter. Voraussetzung: Codex-CLI installiert und eingeloggt. Berichte werden in .shimwrapper/reviews/ gespeichert.",
      "timeoutSec": "Timeout (Sekunden)",
      "timeoutSecTooltip": "Maximale Laufzeit des AI-Reviews in Sekunden. Bei Timeout gilt der Check als fehlgeschlagen. Bei großen Diffs oder vollem Codebase-Modus ggf. erhöhen.",
      "checkMode": "AI-Review-Umfang",
      "checkModeTooltip": "diff: Es wird nur geänderter Code geprüft (staged, unstaged oder zu pushende Commits). Schneller, fokussiert auf deine Änderungen. full (chunked): Die Codebase wird pro Verzeichnis (src, supabase, scripts) geprüft – pro Verzeichnis ein eigener Diff bis 150 KB, ein Codex-Lauf pro Chunk (Timeout 600 s). PASS nur wenn alle Chunks ACCEPT und Score ≥ 95. In der Review-Datei steht „Mode: diff“ bzw. „Mode: full (chunked)“.",
      "checkModeOptionDiff": "diff – nur Änderungen (staged/unstaged oder zu pushende Commits)",
      "checkModeOptionFull": "full – ganze Codebase (gekürzt auf ~100 KB)",
      "diffLimitBytes": "Max. Diff-Größe (Bytes)",
      "diffLimitBytesTooltip": "Maximale Größe des an die AI übergebenen Diffs in Bytes. Wird der Diff größer, wird er gekürzt. Bei „full“-Modus relevant. Standard 51200 (~50 KB).",
      "minRating": "Mindest-Rating für PASS",
      "minRatingTooltip": "Ab welchem Score (0–100) der AI-Review als bestanden gilt. Unter diesem Wert schlägt der Check fehl. Standard 95.",
      "reviewDir": "Ausgabeordner Reviews",
      "reviewDirTooltip": "Verzeichnis, in dem die Review-Berichte (z. B. .md-Dateien) abgelegt werden. Relativer Pfad zum Projekt-Root."
    },
    "explanationCheck": {
      "label": "Full Explanation",
      "summary": "Prüft, ob jeder Code-Abschnitt erklärt ist (Docstrings und Kommentare).",
      "info": "Kontext: Unerklärter Code ist schwer wartbar; dieses Projekt verlangt, dass jede Funktion und nicht-triviale Logik begründet wird. Lösung: Der geänderte Code wird an Codex geschickt; Codex prüft, ob Docstrings und sinnvolle Inline-Kommentare vorhanden sind. Bestanden: Bewertung mindestens 95 und Urteil ACCEPT. Nicht bestanden: Darunter oder REJECT. Berichte in .shimwrapper/reviews/explanation-check-*.md. Voraussetzung: Codex-CLI verfügbar."
    },
    "i18nCheck": {
      "label": "i18n / Übersetzungen",
      "summary": "Prüft, ob alle im Code verwendeten Texte in allen Sprachdateien vorhanden sind.",
      "info": "Kontext: Bei mehrsprachigen Apps müssen alle angezeigten Texte in jeder Sprache definiert sein; fehlen Einträge, sehen Nutzer Schlüssel oder falsche Texte. Lösung: Der Quellcode wird nach Übersetzungsaufrufen durchsucht und mit den Dateien in messages/*.json abgeglichen. Bestanden: Jeder im Code verwendete Schlüssel existiert in jeder Locale-Datei. Nicht bestanden: Mindestens ein Schlüssel fehlt in mindestens einer Sprache. Optional: Mit --fix können fehlende Schlüssel als Platzhalter ergänzt werden (scripts/i18n-check.js)."
    },
    "checkMockData": {
      "label": "Check Mock Data",
      "summary": "Prüft, ob die Mock- bzw. Testdaten des Projekts gültig und konsistent sind.",
      "info": "Kontext: Ungültige oder widersprüchliche Mock-Daten können Tests verfälschen oder Fehler verdecken. Lösung: Das Skript check:mock-data des Projekts wird ausgeführt (falls in package.json definiert). Bestanden: Das Skript endet mit Exit-Code 0. Nicht bestanden: Das Skript meldet Fehler oder endet mit Fehlercode. Ohne definiertes Skript wird der Check übersprungen."
    },
    "updateReadme": {
      "label": "Update README",
      "summary": "Führt ein Skript aus, das z. B. die Version in der README aktualisiert.",
      "info": "Kontext: README und Doku veralten schnell; ein Skript kann zumindest Teile (z. B. Versionsnummer aus package.json) automatisch anpassen. Lösung: Das Update-README-Skript (aus dem Paket oder dem Projekt) wird ausgeführt. Bestanden: Das Skript läuft ohne Fehler. Nicht bestanden: Das Skript schlägt fehl. Hinweis: Was genau aktualisiert wird, hängt vom Skript ab; inhaltliche Änderungen müssen weiterhin manuell erfolgen."
    },
    "sast": {
      "label": "Semgrep",
      "summary": "Statische Analyse mit Semgrep: sucht nach Sicherheitsmustern und Regelverstößen im Code.",
      "info": "Kontext: Semgrep ist ein Tool für statische Code-Analyse (SAST) mit regelbasierten Checks. Lösung: semgrep scan wird ausgeführt (z. B. mit --config auto). Bestanden: Keine Findings. Nicht bestanden: Semgrep meldet Treffer. Tool muss installiert sein (pip install semgrep oder npx semgrep)."
    },
    "gitleaks": {
      "label": "Gitleaks",
      "summary": "Scannt das Repo auf versehentlich committete Secrets (API-Keys, Passwörter).",
      "info": "Kontext: Gitleaks erkennt bekannte Secret-Muster in der Codebasis und im Git-Verlauf. Lösung: gitleaks detect wird ausgeführt. Bestanden: Keine Treffer. Nicht bestanden: Mindestens ein Secret gefunden. Tool muss installiert sein (z. B. Homebrew oder gitleaks.io)."
    },
    "licenseChecker": {
      "label": "license-checker",
      "summary": "Prüft Lizenzen der npm-Abhängigkeiten; schlägt bei nicht erlaubten Lizenzen fehl.",
      "info": "Kontext: Das Tool license-checker listet Lizenzen aller Dependencies. Lösung: npx license-checker wird mit konfigurierbaren erlaubten/verbotenen Lizenzen ausgeführt. Bestanden: Keine verbotenen Lizenzen. Nicht bestanden: Mindestens eine verbotene Lizenz. Über .licensecheckerrc oder CLI-Optionen konfigurierbar."
    },
    "architecture": {
      "label": "dependency-cruiser",
      "summary": "Prüft Abhängigkeitsgraph und Architekturregeln (z. B. keine verbotenen Zyklen).",
      "info": "Kontext: dependency-cruiser prüft den Modul-Graphen gegen Regeln in .dependency-cruiser.json. Lösung: npx depcruise src (oder dashboard) --output-type err. Bestanden: Keine Verstöße. Nicht bestanden: Zirkuläre oder verbotene Abhängigkeiten. Config aus templates/ oder Projekt anlegen."
    },
    "complexity": {
      "label": "Complexity",
      "summary": "Warnt vor zu hoher zyklomatischer Komplexität pro Funktion.",
      "info": "Kontext: eslint-plugin-complexity begrenzt Komplexität (z. B. max 10 pro Funktion). Lösung: ESLint wird mit eslint.complexity.json ausgeführt (Projekt oder templates/). Bestanden: Keine Verstöße. Nicht bestanden: Funktionen über dem Schwellwert. Projekt braucht eslint-plugin-complexity und Config."
    },
    "mutation": {
      "label": "Stryker",
      "summary": "Mutationstests: Prüft, ob Tests echte Fehler finden (Mutanten killen).",
      "info": "Kontext: Stryker verändert Code minimal; bleiben Tests grün, decken sie den Code ggf. nicht ab. Lösung: npx stryker run mit stryker.config.json. Bestanden: Mutations-Score über Schwellwert (z. B. 80 %). Nicht bestanden: Score darunter. Config aus templates/ oder Projekt."
    },
    "e2e": {
      "label": "E2E",
      "summary": "End-to-End-Tests über die ganze App (derzeit nur als Option vorgesehen).",
      "info": "Kontext: E2E-Tests simulieren echte Nutzer und prüfen die App von vorne bis hinten. Lösung: Dieser Check ist in der Konfiguration vorhanden, wird im Standard-run-checks.sh aber noch nicht ausgeführt. Aktivieren speichert nur die Einstellung; die Tests müssen im Projekt eingerichtet sein (z. B. mit Playwright)."
    },
    "healthPing": {
      "label": "Post-Deploy: Health Ping",
      "summary": "Nach dem Deploy: Prüft, ob die bereitgestellten Supabase Functions erreichbar sind und antworten.",
      "info": "Kontext: Nach einem Deploy kann die Anwendung trotzdem nicht erreichbar oder falsch konfiguriert sein; ein kurzer Aufruf bestätigt, dass die Funktion antwortet. Lösung: Nach einem Supabase-Deploy werden die konfigurierten Health-URLs der Edge Functions per HTTP aufgerufen (Skript ping-edge-health.sh). Bestanden: Die aufgerufenen Endpoints antworten (z. B. mit HTTP 200). Nicht bestanden: Keine Antwort oder Fehler. Voraussetzung: Korrekter Project Ref und ggf. passende Health-Pfade.",
      "defaultFunction": "Standard-Funktion",
      "defaultFunctionTooltip": "Name der Edge Function, die standardmäßig per GET aufgerufen wird. Muss einen Health-Endpoint bereitstellen.",
      "healthFunctions": "Zusätzliche Funktionen (kommasepariert)",
      "healthFunctionsTooltip": "Weitere Function-Namen, die nach Deploy angepingt werden sollen. Kommasepariert.",
      "healthPaths": "Health-Pfade (kommasepariert, {fn})",
      "healthPathsTooltip": "Pfade pro Function; {fn} wird durch den Funktionsnamen ersetzt. Leer = Standard-Pfad.",
      "projectRef": "Supabase Project Ref",
      "projectRefTooltip": "Supabase Project Reference (z. B. aus dem Dashboard). Wird für die Health-URL benötigt."
    },
    "edgeLogs": {
      "label": "Post-Deploy: Edge Logs",
      "summary": "Lädt nach dem Deploy die neuesten Logs der Edge Functions zur Kontrolle.",
      "info": "Kontext: Nach einem Deploy zeigen Logs, ob die Funktionen fehlerfrei gestartet sind oder Fehler geworfen haben. Lösung: Nach dem Deploy werden die neuesten Log-Zeilen der konfigurierten Edge Function(s) abgerufen (Skript fetch-edge-logs.sh). Es gibt kein klares Bestanden/Nicht bestanden – die Logs werden nur bereitgestellt; die Bewertung ob alles in Ordnung ist, liegt bei Ihnen.",
      "defaultFunction": "Standard-Funktion",
      "defaultFunctionTooltip": "Funktion, deren Logs standardmäßig abgerufen werden.",
      "logFunctions": "Funktionen für Logs (kommasepariert)",
      "logFunctionsTooltip": "Welche Functions geloggt werden sollen. Kommasepariert; leer = nur defaultFunction.",
      "logLimit": "Anzahl Log-Zeilen",
      "logLimitTooltip": "Maximale Anzahl Log-Zeilen pro Abruf. Höhere Werte = mehr Kontext, längere Ausgabe."
    }
  }
}
