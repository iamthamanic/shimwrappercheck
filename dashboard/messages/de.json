{
  "common": {
    "appName": "shimwrappercheck",
    "dashboard": "Dashboard",
    "settings": "Einstellungen",
    "config": "Config",
    "agentsMd": "AGENTS.md",
    "myshim": "myshim",
    "search": "Suchen...",
    "searchFulltext": "Volltextsuche …",
    "all": "Alle",
    "frontend": "Frontend",
    "backend": "Backend",
    "enforce": "Erzwingen",
    "hooks": "Hooks",
    "info": "Info",
    "description": "Beschreibung",
    "techStack": "Tech Stack",
    "settingsLabel": "Einstellungen",
    "logs": "Logs",
    "noLogYet": "Noch kein Log für diesen Check. Checks ausführen, um Ausgabe zu sehen.",
    "settingsNoExtra": "Keine weiteren Einstellungen. Der Check wird nur über „Aktiv“ (in My Checks) ein- oder ausgeschaltet.",
    "projectRulesTab": "Regeln",
    "projectRulesForm": "Form Mode",
    "projectRulesScript": "Skript Mode",
    "projectRulesScriptPlaceholder": "Skript bearbeiten (wird als scripts/checks/project-rules.sh gespeichert). Exit 0 = bestanden.",
    "projectRulesLoadDefault": "Standard Projektregeln laden",
    "projectRulesScriptEmptyHint": "Noch kein Skript. Klicke auf „Standard (AGENTS.md) laden“ oder schreibe dein eigenes.",
    "projectRulesFormPlaceholder": "Regeln per Formular (z. B. verbotene Imports) kommen in einer späteren Version. Nutze die Skript-Ansicht.",
    "projectRulesSaved": "Skript gespeichert.",
    "projectRulesAddRule": "Regel hinzufügen",
    "projectRulesRuleTypeForbiddenPattern": "Verbotenes Muster",
    "projectRulesRuleTypeForbiddenRegex": "Verbotenes Muster (Regex)",
    "projectRulesRuleTypeMaxLines": "Max. Zeilen pro Datei",
    "projectRulesPatternLabel": "Muster (z. B. ../ oder from '@/../')",
    "projectRulesPatternPlaceholder": "z. B. ../",
    "projectRulesMaxLinesLabel": "Max. Zeilen",
    "projectRulesMaxLinesPlaceholder": "300",
    "projectRulesRuleTypeLabel": "Regeltyp",
    "projectRulesFormEmptyHint": "Noch keine Regeln. Klicke auf „Regel hinzufügen“, dann Speichern.",
    "projectRulesScriptNotParseableHint": "Skript hat kein RULES_JSON-Format. Formular bearbeiten und Speichern überschreibt das Skript.",
    "active": "Aktiv",
    "inactive": "Inaktiv",
    "copy": "Kopieren",
    "copied": "Kopiert!",
    "close": "Schließen",
    "closeLower": "schließen",
    "remove": "Entfernen",
    "save": "Speichern",
    "saving": "Speichern…",
    "saveFailed": "Speichern fehlgeschlagen.",
    "cancel": "Abbrechen",
    "name": "Name",
    "export": "Export",
    "rename": "Umbenennen",
    "loading": "Laden…",
    "preset": "Preset",
    "templates": "Templates",
    "information": "Information",
    "presetsAndSettings": "Templates & Einstellungen",
    "runOrder": "Laufreihenfolge",
    "showLarger": "Größer anzeigen",
    "details": "Details",
    "expandDetails": "Details einblenden",
    "collapseDetails": "Details ausblenden",
    "toolPresent": "vorhanden",
    "toolNotFound": "nicht gefunden",
    "toolLabel": "Tool",
    "statusPresent": "✓ Vorhanden",
    "statusMissing": "— Nicht gefunden",
    "noResults": "Keine Treffer.",
    "dragToActivate": "Ziehen in My Shim zum Aktivieren",
    "addToMyShim": "Zu My Shim hinzufügen",
    "matches": "Treffer",
    "updated": "aktualisiert",
    "unknownCommands": "Unbekannte oder ungültige Befehle",
    "clickToEdit": "Klicken zum Bearbeiten",
    "enforceHint": "Erlaubt: git push, supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksHint": "Nur Supabase: supabase functions deploy, supabase db push, supabase migration, supabase push.",
    "hooksOnlySupabase": "Nur Supabase-Befehle erlaubt.",
    "searchTriggerCommandos": "Volltextsuche in Trigger Commandos",
    "commandEnterPlaceholder": "Befehl eingeben, Enter für neues Tag",
    "commandExampleEnforce": "z.B. git push, Enter für neues Tag",
    "commandExampleHooks": "z.B. supabase functions deploy (nur Supabase), Enter für neues Tag",
    "commandNewTag": "Befehl eingeben, Enter für neues Tag",
    "dropHereActivate": "Hier ablegen – Check aktivieren",
    "dropHereDeactivate": "Hier ablegen – Check deaktivieren",
    "insertHere": "Hier einfügen",
    "noMyChecksYet": "Noch keine My Checks. Aus der Check Library hierher ziehen.",
    "dragFromLibrary": "Checks am ⋮⋮-Symbol (links an der Karte) greifen und in die Fläche oben ziehen.",
    "removeFromMyShim": "Aus My Shim entfernen (zurück in Check Library)",
    "dragToReorder": "Ziehen zum Sortieren",
    "dashboardTitle": "shimwrappercheck Dashboard",
    "dashboardDescription": "Config & AGENTS.md für shimwrappercheck",
    "reviewModeLabel": "Review-Report anlegen",
    "reviews": "Reviews",
    "reviewsIntro": "Wenn der Review-Modus bei einem Check aktiv ist, wird nach jedem Lauf ein Report als .md gespeichert.",
    "reviewsOutputPath": "Speicherort der Review-Reports",
    "reviewsOutputPathHint": "Ordner relativ zum Projekt-Root. Beispiel: reports oder .shimwrapper/reviews",
    "reviewsCheckListTitle": "Alle Checks",
    "reviewsCheckListHint": "Review-Modus pro Check in Templates → My Checks ein- oder ausschalten.",
    "reviewsReportOn": "Report an",
    "reviewsReportOff": "Report aus"
  },
  "nav": {
    "dashboard": "Dashboard",
    "settings": "Einstellungen",
    "config": "Config",
    "agentsMd": "AGENTS.md"
  },
  "header": {
    "settingsAria": "Einstellungen"
  },
  "sidebar": {
    "myActiveShim": "Mein aktiver Shim"
  },
  "triggerCommandos": {
    "title": "Meine Trigger-Commandos"
  },
  "checkLibrary": {
    "title": "Check-Bibliothek",
    "scanCodebase": "Suggest Checks",
    "scanCodebaseScanning": "Scanne…",
    "scanError": "Scan fehlgeschlagen. Bitte erneut versuchen.",
    "clickToDismiss": "Klicken zum Schließen",
    "whySuggested": "Warum vorgeschlagen",
    "close": "Schließen"
  },
  "myChecks": {
    "title": "Meine Checks",
    "showIdealOrderTemplate": "Empfohlene Reihenfolge",
    "idealOrderHint": "Empfohlene Reihenfolge – Checks hier aktivieren oder in der Liste entfernen.",
    "addToMyChecks": "Hinzufügen"
  },
  "settings": {
    "loadError": "Einstellungen konnten nicht geladen werden.",
    "timeout": "Zeitüberschreitung. Bitte erneut versuchen.",
    "loadFailed": "Laden fehlgeschlagen.",
    "retry": "Erneut versuchen",
    "saved": "Einstellungen gespeichert.",
    "saveFailed": "Speichern fehlgeschlagen.",
    "savedShort": "Gespeichert.",
    "presetRenamed": "Preset umbenannt.",
    "uiPortTitle": "Grafische UI – Port",
    "uiPortDesc": "Auf welchem Port die UI starten soll oder ob automatisch ein freier Port gewählt wird.",
    "portAuto": "Automatisch einen freien Port wählen",
    "portFixed": "Fester Port:",
    "savePort": "Port-Einstellung speichern",
    "version": "Version:",
    "lastUpdated": "Zuletzt aktualisiert:",
    "statusTitle": "Status",
    "projectRoot": "Projekt-Root:",
    "lastCheckError": "Letzter Check-Fehler (.shim/last_error.json)",
    "suggestion": "Vorschlag:",
    "actionsTitle": "Aktionen",
    "runChecks": "Nur Checks ausführen",
    "running": "Läuft…",
    "configRaw": "Config (Raw)",
    "editAgentsMd": "AGENTS.md bearbeiten",
    "lastCheckOutput": "Letzte Check-Ausgabe",
    "ok": "(OK)",
    "error": "(Fehler)",
    "noOutput": "(keine Ausgabe)",
    "presetIntro": "Preset wählen und Checks ein-/ausschalten. Trigger-Befehle (Supabase/Git) legst du in My Shim fest. Speichern schreibt .shimwrappercheckrc.",
    "presetStorageHint": "Presets werden in diesem Projekt gespeichert. Export nutzen, um sie in einem anderen Projekt wiederzuverwenden.",
    "presetTitle": "Preset",
    "presetOptions": "Optionen für aktives Preset",
    "presetOptionsAria": "Preset-Optionen",
    "deletePreset": "Preset löschen",
    "newPreset": "Neues Preset",
    "createPreset": "Anlegen",
    "exportPreset": "Preset exportieren",
    "exportFilenameHint": "Dateiname (wird als .json heruntergeladen):",
    "exportPlaceholder": "mein-preset.json",
    "renamePreset": "Preset umbenennen",
    "renamePresetHint": "Neuer Name (wird auch in My Shim angezeigt):",
    "providersTitle": "Provider in diesem Preset",
    "providersDesc": "Provider hinzufügen (z. B. GitHub, Supabase).",
    "github": "GitHub",
    "supabase": "Supabase",
    "removeProvider": "entfernen",
    "runChecksRequestFailed": "Anfrage fehlgeschlagen."
  },
  "statusCard": {
    "configRc": ".shimwrappercheckrc",
    "presetsFile": "Presets (.shimwrappercheck-presets.json)",
    "presetsDetail": "Presets & Check-Toggles (Einstellungen)",
    "agentsMd": "AGENTS.md",
    "agentsMdDetail": "Agent-Anweisungen (über GUI bearbeitbar)",
    "runChecksScript": "scripts/run-checks.sh",
    "shimRunner": "Shim Runner",
    "shimRunnerDetail": "Node-Orchestrator (npx shimwrappercheck run)",
    "huskyPrePush": "Husky pre-push",
    "gitPrePushHook": "Git pre-push Hook",
    "supabase": "Supabase"
  },
  "config": {
    "title": "Config (.shimwrappercheckrc)",
    "description": "Shell-Variablen und Kommentare. Wird beim nächsten Aufruf des Shims verwendet.",
    "placeholder": "# shimwrappercheck config\nSHIM_ENFORCE_COMMANDS=\"functions,db,migration\"\n...",
    "saved": "Config gespeichert."
  },
  "agents": {
    "title": "AGENTS.md",
    "description": "Agent-Anweisungen für Cursor/Codex. Wird von Agents gelesen; hier bearbeitbar. Änderungen gelten sofort.",
    "notExists": "AGENTS.md existiert noch nicht. Beim Speichern wird sie im Projekt-Root angelegt.",
    "placeholder": "# Agent instructions...",
    "saved": "AGENTS.md gespeichert."
  },
  "notFound": {
    "title": "Seite nicht gefunden",
    "description": "Die angeforderte URL existiert nicht."
  },
  "error": {
    "title": "Fehler",
    "fallbackMessage": "Ein unerwarteter Fehler ist aufgetreten.",
    "retry": "Erneut versuchen"
  },
  "checks": {
    "lint": {
      "label": "ESLint",
      "summary": "Findet Regel- und Qualitätsverstöße im Code.",
      "info": "Zweck: Verhindert typische Fehler und Stilbrüche, bevor sie in Produktion landen. Prüft: Projektdateien mit ESLint-Regeln (`npm run lint`). Bestanden, wenn: Der ESLint-Lauf endet ohne Fehler (Exit 0). Nicht bestanden, wenn: ESLint Fehler meldet (Exit != 0). Anpassen: ESLint-Config und Regeln im Projekt."
    },
    "prettier": {
      "label": "Prettier",
      "summary": "Sichert ein einheitliches Code-Format.",
      "info": "Zweck: Einheitliche Formatierung ohne Diskussionen. Prüft: Prettier im Check-Modus (`npm run format:check` oder `prettier --check`). Bestanden, wenn: Keine Formatabweichungen gefunden werden. Nicht bestanden, wenn: Formatabweichungen gefunden werden. Anpassen: Prettier-Config im Projekt."
    },
    "typecheck": {
      "label": "TypeScript Check",
      "summary": "Findet TypeScript-Typfehler vor dem Lauf.",
      "info": "Zweck: Verhindert Laufzeitfehler durch falsche Typen. Prüft: `tsc --noEmit` (oder `npm run typecheck`). Bestanden, wenn: Keine Typfehler (Exit 0). Nicht bestanden, wenn: Der Compiler Fehler meldet. Anpassen: `tsconfig.json` und TypeScript-Regeln."
    },
    "testRun": {
      "label": "Vitest",
      "summary": "Führt Build und Tests aus.",
      "info": "Zweck: Sicherstellen, dass die App nach Änderungen weiterhin funktioniert. Prüft: `npm run build` und `npm run test:run`. Bestanden, wenn: Build und Tests erfolgreich sind. Nicht bestanden, wenn: Build oder Tests fehlschlagen. Anpassen: Build- und Test-Skripte in `package.json`."
    },
    "projectRules": {
      "label": "Projektregeln",
      "summary": "Erzwingt projektspezifische Regeln (z. B. Struktur, Imports).",
      "info": "Zweck: Sichert Teamregeln, die Lint nicht abdeckt. Prüft: `scripts/checks/project-rules.sh` (falls vorhanden). Bestanden, wenn: Das Script endet ohne Fehler (Exit 0). Nicht bestanden, wenn: Das Script meldet Verstöße (Exit != 0). Anpassen: Regeln im Script. Hinweis: Fehlt das Script, wird der Check übersprungen."
    },
    "npmAudit": {
      "label": "npm audit",
      "summary": "Scannt npm-Abhängigkeiten auf bekannte Sicherheitslücken.",
      "info": "Zweck: Stoppt Builds bei bekannten Schwachstellen. Prüft: `npm audit` mit konfigurierter Schweregrad-Schwelle. Bestanden, wenn: Keine Findings ab der Schwelle. Nicht bestanden, wenn: Mindestens ein Finding ab der Schwelle. Anpassen: `auditLevel` oder `SHIM_AUDIT_LEVEL`.",
      "auditLevel": "Audit-Stufe",
      "auditLevelTooltip": "Ab welcher Schwere der Check fehlschlägt: critical (nur Kritisch), high (Kritisch + Hoch), moderate (+ Mittel), low (+ Niedrig). Höhere Stufen = strenger."
    },
    "viteBuild": {
      "label": "Vite",
      "summary": "Stellt sicher, dass das Frontend gebaut werden kann.",
      "info": "Zweck: Verhindert Deploys mit Build-Fehlern. Prüft: `npm run build`. Bestanden, wenn: Der Build erfolgreich endet. Nicht bestanden, wenn: Der Build fehlschlägt. Anpassen: Build-Skript in `package.json`."
    },
    "snyk": {
      "label": "Snyk",
      "summary": "Optionaler Security-Scan mit Snyk.",
      "info": "Zweck: Findet zusätzliche Schwachstellen in Dependencies. Prüft: `snyk test`, wenn Snyk installiert ist. Bestanden, wenn: Keine Findings oder Snyk nicht installiert (übersprungen). Nicht bestanden, wenn: Snyk Findings meldet. Anpassen: `.snyk` Policy; Skip mit `SKIP_SNYK=1`."
    },
    "denoFmt": {
      "label": "Deno fmt",
      "summary": "Prüft Formatierung der Supabase Edge Functions.",
      "info": "Zweck: Einheitliches Format im Deno-Code. Prüft: `deno fmt --check supabase/functions`. Bestanden, wenn: Keine Abweichungen gefunden werden. Nicht bestanden, wenn: Abweichungen vorhanden sind. Hinweis: Wird übersprungen, wenn `supabase/functions` fehlt."
    },
    "denoLint": {
      "label": "Deno lint",
      "summary": "Lintet Deno-Code der Edge Functions.",
      "info": "Zweck: Findet Fehler und schlechte Praxis im Deno-Code. Prüft: `deno lint supabase/functions`. Bestanden, wenn: Keine Meldungen. Nicht bestanden, wenn: Linter Meldungen ausgibt. Hinweis: Wird übersprungen, wenn `supabase/functions` fehlt."
    },
    "denoAudit": {
      "label": "Deno audit",
      "summary": "Sicherheitscheck für Deno-Abhängigkeiten.",
      "info": "Zweck: Schützt vor bekannten Sicherheitslücken in Deno-Dependencies. Prüft: `deno audit` in `supabase/functions/server`. Bestanden, wenn: Keine Findings. Nicht bestanden, wenn: Findings gemeldet werden. Hinweis: Wird übersprungen, wenn `supabase/functions` fehlt."
    },
    "aiReview": {
      "label": "AI Review",
      "summary": "KI-Review mit fester Checkliste (SOLID, DRY, Security, Robustheit, Wartbarkeit).",
      "info": "Zweck: Zweitmeinung zu Architektur, Sicherheit und Wartbarkeit. Prüft: Codex bewertet Snippets (geänderten Code), Full-Scan oder den Mix-Loop und liefert Score + Verdict. Bestanden, wenn: Verdict `ACCEPT` und Score >= Mindestwert (Standard 95). Nicht bestanden, wenn: `REJECT` oder Score darunter. Anpassen: `CHECK_MODE`, Mindestscore, Timeout und optional `SHIM_REFACTOR_MODE` (Item-Handoff bei Refactor-Läufen). Hinweis: Reviews liegen in `.shimwrapper/reviews/`; Codex-CLI erforderlich.",
      "timeoutSec": "Timeout (Sekunden)",
      "timeoutSecTooltip": "Maximale Laufzeit des AI-Reviews in Sekunden. Bei Timeout gilt der Check als fehlgeschlagen. Bei großen Diffs oder vollem Codebase-Modus ggf. erhöhen.",
      "checkMode": "AI-Review-Umfang",
      "checkModeTooltip": "mix: Refactor-Loop-Modus (manueller run-checks = full chunked Scan, pre-push = snippet). snippet: Es werden nur geänderte Code-Snippets geprüft (staged, unstaged oder zu pushende Commits). Schneller, fokussiert auf deine Änderungen. full (chunked): Die Codebase wird pro Verzeichnis (src, supabase, scripts, dashboard) geprüft – pro Verzeichnis ein eigener Diff bis 150 KB, ein Codex-Lauf pro Chunk (Timeout 600 s). PASS nur wenn alle Chunks ACCEPT und Score ≥ 95. Review-Dateien heißen review-snippet-... bzw. review-full-... .",
      "checkModeOptionMix": "mix – Refactor-Loop (manuell full scan, beim Push snippet review)",
      "checkModeOptionSnippet": "snippet – nur geänderte Code-Snippets (staged/unstaged oder zu pushende Commits)",
      "checkModeOptionFull": "full – ganze Codebase (chunked pro Verzeichnis)",
      "refactorMode": "Refactor-Orchestrierung",
      "refactorModeTooltip": "Steuert optionale Refactor-Item-Artefakte für --refactor-Läufe: off = aus, interactive = aktuelles Item + Resume-Hinweise, agent = Handoff-JSON pro Item.",
      "refactorModeOptionOff": "off – kein Item-Flow",
      "refactorModeOptionInteractive": "interactive – aktuelles Item + Resume-Hinweise",
      "refactorModeOptionAgent": "agent – Handoff-Artefakte pro Item",
      "diffLimitBytes": "Max. Diff-Größe (Bytes)",
      "diffLimitBytesTooltip": "Maximale Größe des an die AI übergebenen Diffs in Bytes. Wird der Diff größer, wird er gekürzt. Bei „full“-Modus relevant. Standard 51200 (~50 KB).",
      "minRating": "Mindest-Rating für PASS",
      "minRatingTooltip": "Ab welchem Score (0–100) der AI-Review als bestanden gilt. Unter diesem Wert schlägt der Check fehl. Standard 95.",
      "reviewDir": "Ausgabeordner Reviews",
      "reviewDirTooltip": "Verzeichnis, in dem die Review-Berichte (z. B. .md-Dateien) abgelegt werden. Relativer Pfad zum Projekt-Root."
    },
    "explanationCheck": {
      "label": "Full Explanation",
      "summary": "Erfordert erklärten Code (Docstrings + Kommentare).",
      "info": "Zweck: Erhöht Verständlichkeit und Wartbarkeit. Prüft: Codex bewertet Docstrings und Kommentare für nicht-triviale Logik. Bestanden, wenn: Verdict `ACCEPT` und Score >= 95. Nicht bestanden, wenn: `REJECT` oder Score darunter. Anpassen: `.shimwrappercheckrc` (SHIM_RUN_EXPLANATION_CHECK) oder `--no-explanation-check`. Hinweis: Report in `.shimwrapper/reviews/explanation-check-*.md`."
    },
    "i18nCheck": {
      "label": "i18n / Übersetzungen",
      "summary": "Sichert, dass alle Übersetzungs-Keys existieren.",
      "info": "Zweck: Verhindert fehlende Texte in der UI. Prüft: Übersetzungs-Keys im Code gegen alle `messages/*.json`. Bestanden, wenn: Jeder verwendete Key in jeder Locale vorhanden ist. Nicht bestanden, wenn: Mindestens ein Key fehlt. Anpassen: `--fix` ergänzt Platzhalter; Skip mit `--no-i18n-check`. Hinweis: Benötigt `scripts/i18n-check.js`."
    },
    "checkMockData": {
      "label": "Check Mock Data",
      "summary": "Validiert projektinterne Mock- und Testdaten.",
      "info": "Zweck: Verhindert fehlerhafte Tests durch ungültige Mock-Daten. Prüft: `npm run check:mock-data`. Bestanden, wenn: Das Script endet ohne Fehler (Exit 0). Nicht bestanden, wenn: Das Script fehlschlägt oder fehlt. Anpassen: Script in `package.json` definieren."
    },
    "updateReadme": {
      "label": "Update README",
      "summary": "Aktualisiert README-Teile per Script.",
      "info": "Zweck: Hält z. B. Versionsangaben konsistent. Prüft: `scripts/update-readme.js` (Projekt) oder shimwrappercheck-Script. Bestanden, wenn: Script erfolgreich läuft oder nicht vorhanden ist (übersprungen). Nicht bestanden, wenn: Ein Script vorhanden ist und fehlschlägt. Anpassen: Script im Projekt bereitstellen oder anpassen."
    },
    "sast": {
      "label": "Semgrep",
      "summary": "SAST-Scan mit Semgrep.",
      "info": "Zweck: Findet Sicherheitsmuster im Code. Prüft: `semgrep scan --config auto --error`. Bestanden, wenn: Keine Findings. Nicht bestanden, wenn: Findings gemeldet werden. Anpassen: Semgrep-Regeln/Config. Hinweis: Wird übersprungen, wenn Semgrep nicht installiert ist."
    },
    "gitleaks": {
      "label": "Gitleaks",
      "summary": "Findet Secrets im Repository.",
      "info": "Zweck: Verhindert API-Keys oder Passwörter im Code. Prüft: `gitleaks detect` gegen den Arbeitsbaum (nutzt `.gitleaks.toml` falls vorhanden). Bestanden, wenn: Keine Treffer. Nicht bestanden, wenn: Treffer gefunden werden. Anpassen: `.gitleaks.toml`. Hinweis: Wird übersprungen, wenn Gitleaks nicht installiert ist."
    },
    "licenseChecker": {
      "label": "license-checker",
      "summary": "Erstellt eine Lizenzübersicht der npm-Abhängigkeiten.",
      "info": "Zweck: Zeigt, welche Lizenzen eure Dependencies haben. Prüft: `npx license-checker --summary` (liest `.licensecheckerrc`). Bestanden, wenn: Der Befehl läuft (Standard-Runner wertet das Ergebnis nicht als Fehler). Nicht bestanden, wenn: In einem strikten Runner verbotene Lizenzen gefunden werden oder der Befehl fehlschlägt. Anpassen: `.licensecheckerrc` oder CLI-Optionen. Hinweis: `run-checks.sh` erzwingt standardmäßig keinen Fail."
    },
    "architecture": {
      "label": "dependency-cruiser",
      "summary": "Prüft Architekturregeln und verbotene Abhängigkeiten.",
      "info": "Zweck: Erzwingt Modulgrenzen und verhindert Zyklen. Prüft: dependency-cruiser gegen `.dependency-cruiser.json`. Bestanden, wenn: Keine Regelverstöße. Nicht bestanden, wenn: Zyklen oder verbotene Abhängigkeiten gefunden werden. Anpassen: `.dependency-cruiser.json`. Hinweis: Wird übersprungen, wenn die Config fehlt."
    },
    "complexity": {
      "label": "Complexity",
      "summary": "Begrenzt die Komplexität einzelner Funktionen.",
      "info": "Zweck: Hält Funktionen klein und verständlich. Prüft: ESLint mit `eslint-plugin-complexity` und Config. Bestanden, wenn: Keine Funktion über dem Schwellwert. Nicht bestanden, wenn: Schwellwert überschritten. Anpassen: `eslint.complexity.json`. Hinweis: Wird übersprungen, wenn keine Config gefunden wird."
    },
    "mutation": {
      "label": "Stryker",
      "summary": "Misst Testqualität mit Mutationstests.",
      "info": "Zweck: Prüft, ob Tests echte Fehler erkennen. Prüft: `npx stryker run` mit `stryker.config.json`. Bestanden, wenn: Mutations-Score über dem Schwellwert. Nicht bestanden, wenn: Score darunter oder Lauf fehlschlägt. Anpassen: `stryker.config.json`. Hinweis: Wird übersprungen, wenn die Config fehlt."
    },
    "e2e": {
      "label": "E2E",
      "summary": "Option für End-to-End-Tests (muss im Projekt eingerichtet sein).",
      "info": "Zweck: Testet komplette Nutzerflüsse. Prüft: Im Standard-Runner nicht ausgeführt; Aktivieren speichert nur die Einstellung. Bestanden, wenn: Abhängig von eurem E2E-Skript. Nicht bestanden, wenn: Abhängig von eurem E2E-Skript. Anpassen: E2E-Kommando im eigenen `run-checks.sh`."
    },
    "ruff": {
      "label": "Ruff (Python)",
      "summary": "Lint und Format für Python-Code.",
      "info": "Zweck: Verhindert Fehler und einheitliche Formatierung in Python-Dateien. Prüft: `ruff check .` und `ruff format --check .`. Bestanden, wenn: Beide Befehle enden ohne Fehler (Exit 0). Nicht bestanden, wenn: Ruff Lint- oder Format-Verstöße meldet. Anpassen: `pyproject.toml` oder `ruff.toml`. Hinweis: Wird übersprungen, wenn weder Python-Dateien noch pyproject.toml/requirements.txt vorhanden sind oder Ruff nicht installiert ist (z. B. pip install ruff, brew install ruff)."
    },
    "shellcheck": {
      "label": "Shellcheck (Shell)",
      "summary": "Findet typische Fehler in Shell-Skripten.",
      "info": "Zweck: Verhindert Fehler und unsichere Praxis in Bash-/Shell-Skripten. Prüft: Alle `.sh`-Dateien (außer node_modules, .git) mit shellcheck. Bestanden, wenn: Keine Meldungen (Exit 0). Nicht bestanden, wenn: shellcheck Fehler oder Warnungen meldet. Anpassen: `.shellcheckrc` oder Direktiven im Skript. Hinweis: Wird übersprungen, wenn keine .sh-Dateien gefunden werden oder shellcheck nicht installiert ist (z. B. brew install shellcheck)."
    },
    "healthPing": {
      "label": "Post-Deploy: Health Ping",
      "summary": "Nach dem Deploy: ruft Health-Endpoints auf.",
      "info": "Zweck: Prüft, ob Functions nach dem Deploy antworten. Prüft: Konfigurierte Health-URLs der Edge Functions. Bestanden, wenn: Alle Endpoints erfolgreich antworten (z. B. HTTP 200). Nicht bestanden, wenn: Timeouts oder Fehlercodes auftreten. Anpassen: Project Ref, Funktionsnamen und Pfade.",
      "defaultFunction": "Standard-Funktion",
      "defaultFunctionTooltip": "Name der Edge Function, die standardmäßig per GET aufgerufen wird. Muss einen Health-Endpoint bereitstellen.",
      "healthFunctions": "Zusätzliche Funktionen (kommasepariert)",
      "healthFunctionsTooltip": "Weitere Function-Namen, die nach Deploy angepingt werden sollen. Kommasepariert.",
      "healthPaths": "Health-Pfade (kommasepariert, {fn})",
      "healthPathsTooltip": "Pfade pro Function; {fn} wird durch den Funktionsnamen ersetzt. Leer = Standard-Pfad.",
      "projectRef": "Supabase Project Ref",
      "projectRefTooltip": "Supabase Project Reference (z. B. aus dem Dashboard). Wird für die Health-URL benötigt."
    },
    "edgeLogs": {
      "label": "Post-Deploy: Edge Logs",
      "summary": "Nach dem Deploy: zeigt die neuesten Edge-Logs.",
      "info": "Zweck: Schnelle Sichtprüfung nach dem Deploy. Prüft: Ruft die neuesten Logzeilen der Functions ab. Bestanden, wenn: Nicht zutreffend (Logs dienen nur zur Ansicht). Nicht bestanden, wenn: Nicht zutreffend. Anpassen: Funktionsnamen und Log-Limit.",
      "defaultFunction": "Standard-Funktion",
      "defaultFunctionTooltip": "Funktion, deren Logs standardmäßig abgerufen werden.",
      "logFunctions": "Funktionen für Logs (kommasepariert)",
      "logFunctionsTooltip": "Welche Functions geloggt werden sollen. Kommasepariert; leer = nur defaultFunction.",
      "logLimit": "Anzahl Log-Zeilen",
      "logLimitTooltip": "Maximale Anzahl Log-Zeilen pro Abruf. Höhere Werte = mehr Kontext, längere Ausgabe."
    }
  }
}
